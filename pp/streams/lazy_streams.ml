(** Type representing a lazy stream, where each stream consists of a head element
and a lazily evaluated tail. The tail is a lazy value that is only computed
when needed. *)
type 'a lazystream = Cons of 'a * 'a lazystream Lazy.t

(** [from n] creates an infinite lazy stream of integers starting from [n].
    @param n The starting integer for the stream.
    @return An infinite lazy stream of integers [n, n+1, n+2, ...]. *)
let rec from n = Cons(n, lazy(from (n +1)))

(** [nats] is an infinite lazy stream of natural numbers starting from 1. *)
let nats = from 1

(** [hd s] returns the head of the lazy stream [s].
    @param s The input lazy stream.
    @return The first element of the stream. *)
let hd (Cons(h, _)) = h

(** [tl s] returns the tail of the lazy stream [s], forcing its evaluation.
    @param s The input lazy stream.
    @return The tail of the stream. *)
let tl (Cons(_, t)) = Lazy.force t

(** [take n s] takes the first [n] elements from the lazy stream [s] and returns them as a list.
    @param n The number of elements to take.
    @param s The input lazy stream.
    @return A list containing the first [n] elements of [s]. *)
let rec take n (Cons(h, t)) = 
  if n <= 0 then []
  else h :: take (n-1) (Lazy.force t)

(** [drop n s] drops the first [n] elements from the lazy stream [s] and returns the rest of the stream.
    @param n The number of elements to drop.
    @param s The input lazy stream.
    @return The remaining lazy stream after dropping the first [n] elements. *)
let rec drop n (Cons(h, t) as s) = 
  if n <= 0 then s
  else drop (n-1) @@ (Lazy.force t)

(** [map f s] applies the function [f] to each element of the lazy stream [s].
    @param f The function to apply to each element.
    @param s The input lazy stream.
    @return A new lazy stream with [f] applied to each element of [s]. *)
let rec map f (Cons(h, t)) = 
  Cons(f h, lazy(map f (Lazy.force t)))


(** [map2 f s1 s2] applies the function [f] to corresponding elements of the lazy streams [s1] and [s2].
    @param f The function to apply to each pair of elements.
    @param s1 The first input lazy stream.
    @param s2 The second input lazy stream.
    @return A new lazy stream with [f] applied to each pair of elements from [s1] and [s2]. *)
let rec map2 f (Cons (h1, t1)) (Cons (h2, t2)) =
  Cons (f h1 h2, lazy (map2 f (Lazy.force t1) (Lazy.force t2)))

(** [sum] is a function that sums corresponding elements of two lazy streams.
  It is equivalent to [map2 (+)]. *)
let sum = map2 (+)

(** [fibs] is an infinite lazy stream of Fibonacci numbers.
    The sequence starts with [0, 1] and each subsequent element is the sum of the previous two. *)
let tl (Cons(_, t)) = Lazy.force t
let rec fibs =
  Cons (0, lazy (Cons (1, lazy (sum fibs (tl fibs)))))

(** [unfold f x] generates an infinite lazy stream based on a seed value [x] and a function [f].
    @param f A function that takes a value and returns a pair: the next element of the stream and the new seed.
    @param x The initial seed value.
    @return An infinite lazy stream generated by repeatedly applying [f]. *)
let rec unfold f x = 
  let (h, t) = f x in
  Cons(x, lazy( unfold f t))

(* More questinos *)


(* 1. What is a lazy stream in OCaml? How does it differ from a regular list?

A lazy stream in OCaml is a potentially infinite sequence of elements where the computation of each element is deferred until it is explicitly required. Unlike a regular list, which is eagerly evaluated and finite, a lazy stream calculates its elements lazily, allowing it to represent infinite sequences.


2. Write the type definition for a lazy stream.
type 'a lazystream = Cons of 'a * (unit -> 'a lazystream)
type 'a lazystream = Cons of 'a * 'a lazystream Lazy.t

3. Explain the purpose of the `Lazy.force` function when working with lazy streams.
The Lazy.force function evaluates a lazy value of type Lazy.t. When working with lazy streams, Lazy.force is used to compute the tail of the stream (or any deferred computation) on-demand, making the next portion of the stream available. *)




(* 1. **Defining Lazy Streams**  
  Write a function `from` that generates an infinite lazy stream of integers 
  starting from a given number.  
*)

type 'a lazystream = Cons of 'a * 'a lazystream Lazy.t
let rec from n = Cons(n, lazy( from (n+1)) )



(* 2. **Take Function**  
   Implement a function `take` that retrieves the first `n` elements 
   from a lazy stream as a list.  

   let rec take (n : int) (s : 'a stream) : 'a list = ...
*)
let rec take n (Cons (h, t)) = 
  if n <= 0 then [] else h :: take (n-1) (Lazy.force t)

(* 3. **Map Function**  
   Implement a function `map` that applies a function 
   to every element of a lazy stream.  

   let rec map (f : 'a -> 'b) (s : 'a stream) : 'b stream = ...
*)
let rec map f (Cons (h,t)) = Cons(f h, lazy( map f (Lazy.force t)))


(* 1. **Fibonacci Sequence**  
   Use lazy streams to generate an infinite stream of Fibonacci numbers. 
   Write the code for the Fibonacci stream and 
   demonstrate retrieving the first 10 Fibonacci numbers. *)
type 'a lazystream = Cons of 'a * 'a lazystream Lazy.t
(* let rec from n = Cons(n, lazy(from ( n + 1 )) ) *)
let hd (Cons (h, _)) = h
let tl (Cons (_, t)) = Lazy.force t

let rec map2 f (Cons(h1, t1)) (Cons(h2, t2)) = 
  Cons((f h1 h2), lazy(map2 f (Lazy.force t1) (Lazy.force t2)))

let sum = map2 (+)

let rec fibs = 
  Cons(0, lazy(Cons(1, lazy(sum fibs (tl fibs)))))
let rec result n (Cons(h,t)) = if n > 1 then result (n-1) (Lazy.force t) else h


(* 2. **Filtering Streams**  
   Write a function `filter` that takes a predicate and a stream, 
   and returns a new stream containing only the elements that satisfy the predicate. 
   Demonstrate this by filtering out all even numbers 
   from an infinite stream of integers starting at 1. *)
let rec filter f (Cons(h,t)) = 
  if f h then (Cons(h, lazy(filter f (Lazy.force t))))
  else filter f (Lazy.force t)

(* 3. **Prime Numbers**  
   Implement the Sieve of Eratosthenes using lazy streams 
   to generate an infinite stream of prime numbers. *)
type 'a lazystream = Cons of 'a * 'a lazystream Lazy.t

let rec nats n = Cons(n, lazy( nats(n+1) ))

let rec filter f (Cons(h,t)) = 
  if f h then (Cons(h, lazy(filter f (Lazy.force t))))
  else filter f (Lazy.force t)

let rec soe (Cons(h,t)) = Cons(h, lazy(filter (fun x -> x mod h <> 0) (Lazy.force t)))
let soe_answer = soe (nats 2)





(* 1. Discuss the advantages and disadvantages of using lazy streams over other data structures in OCaml for processing large datasets or infinite sequences. *)
(* 2. Explain how OCaml's garbage collector interacts with lazy streams. What happens to unused elements of a lazy stream? *)
(* 3. Modify the `from` function (from Section B) so that it generates a stream where each value is computed lazily. *)

(* 1. The following implementation of a stream has a memory leak. Identify and fix the issue:  
   ```ocaml
   type 'a stream = Cons of 'a * (unit -> 'a stream)

   let rec from n = Cons (n, fun () -> from (n + 1))

   let take n s =
     let rec aux acc n s =
       if n = 0 then List.rev acc
       else match s with Cons (x, xs) -> aux (x :: acc) (n - 1) (Lazy.force xs)
     in
     aux [] n s
   ``` *)

(* 2. Rewrite the `map` function to use tail recursion (if possible). Discuss why tail recursion might or might not be necessary in this case. *)

