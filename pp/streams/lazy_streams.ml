(** Type representing a lazy stream, where each stream consists of a head element
and a lazily evaluated tail. The tail is a lazy value that is only computed
when needed. *)
type 'a lazystream = Cons of 'a * 'a lazystream Lazy.t

(** [from n] creates an infinite lazy stream of integers starting from [n].
    @param n The starting integer for the stream.
    @return An infinite lazy stream of integers [n, n+1, n+2, ...]. *)
let rec from n = Cons(n, lazy(from (n +1)))

(** [nats] is an infinite lazy stream of natural numbers starting from 1. *)
let nats = from 1

(** [hd s] returns the head of the lazy stream [s].
    @param s The input lazy stream.
    @return The first element of the stream. *)
let hd (Cons(h, _)) = h

(** [tl s] returns the tail of the lazy stream [s], forcing its evaluation.
    @param s The input lazy stream.
    @return The tail of the stream. *)
let tl (Cons(_, t)) = Lazy.force t

(** [take n s] takes the first [n] elements from the lazy stream [s] and returns them as a list.
    @param n The number of elements to take.
    @param s The input lazy stream.
    @return A list containing the first [n] elements of [s]. *)
let rec take n (Cons(h, t)) = 
  if n <= 0 then []
  else h :: take (n-1) (Lazy.force t)

(** [drop n s] drops the first [n] elements from the lazy stream [s] and returns the rest of the stream.
    @param n The number of elements to drop.
    @param s The input lazy stream.
    @return The remaining lazy stream after dropping the first [n] elements. *)
let rec drop n (Cons(h, t) as s) = 
  if n <= 0 then s
  else drop (n-1) @@ (Lazy.force t)

(** [map f s] applies the function [f] to each element of the lazy stream [s].
    @param f The function to apply to each element.
    @param s The input lazy stream.
    @return A new lazy stream with [f] applied to each element of [s]. *)
let rec map f (Cons(h, t)) = 
  Cons(f h, lazy(map f (Lazy.force t)))


(** [map2 f s1 s2] applies the function [f] to corresponding elements of the lazy streams [s1] and [s2].
    @param f The function to apply to each pair of elements.
    @param s1 The first input lazy stream.
    @param s2 The second input lazy stream.
    @return A new lazy stream with [f] applied to each pair of elements from [s1] and [s2]. *)
let rec map2 f (Cons (h1, t1)) (Cons (h2, t2)) =
  Cons (f h1 h2, lazy (map2 f (Lazy.force t1) (Lazy.force t2)))

(** [sum] is a function that sums corresponding elements of two lazy streams.
  It is equivalent to [map2 (+)]. *)
let sum = map2 (+)

(** [fibs] is an infinite lazy stream of Fibonacci numbers.
    The sequence starts with [0, 1] and each subsequent element is the sum of the previous two. *)
let rec fibs =
  Cons (0, lazy (Cons (1, lazy (sum fibs (tl fibs)))))

(** [unfold f x] generates an infinite lazy stream based on a seed value [x] and a function [f].
    @param f A function that takes a value and returns a pair: the next element of the stream and the new seed.
    @param x The initial seed value.
    @return An infinite lazy stream generated by repeatedly applying [f]. *)
let rec unfold f x = 
  let (h, t) = f x in
  Cons(x, lazy( unfold f t))

(* More questinos *)